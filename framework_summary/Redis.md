# Redis

## 1. 过期键相关

### 1.1 过期键的删除策略

- 定时删除：对每一个设置了过期时间的key都创建一个定时器，当过期时间到达时，利用定时器删除对应的key
- 惰性删除：只有在获取key时才判断key是否过期并做对应的操作，其他时间都放任不管
- 定期删除：每隔一段时间，程序对数据库进行检查（范围检查，并不时一次性全部扫描），删除对应的过期间

各自优略势：

- 定时删除：内存友好，但CPU不友好，过期键较多的情况下，删除过期键可能会占用一部分CPU。而且定时器是时间事件，redis中时间事件是保存再无序链表中的，查找一个时间事件可能要排查整个链表。
- **惰性删除**：CPU友好，设计也更简单，但内存不友好。没查询的键就永远不会删除，就算设置了过期时间
- **定期删除**：一种折中方案，既可以不用频繁占用CPU，也可以保证设置了过期时间的key再某个时刻一定能被删除。但如何设计一个最佳的定时检测时间间隔和检测范围，是需要不断摸索的

Redis的过期键删除策略：

**惰性删除和定期删除**，在每次获取键时，都判断ttl是否过期。同时设计了一个时间事件，来扫描一部分key，下次触发时再接着上次扫描，直到一轮扫描完毕，再从头开始

## 2. 持久化

### 2.1 RDB（Redis Database）

​		将redis数据库里的数据保存在一个经过压缩的二进制文件里，通过该文件可以完整的还原Redis数据库内容。**当redis启动时，如果没开启AOP，则会自动的读取RDB文件并还原数据**

**实现方式：**

- **SAVE**：阻塞同步的进行RDB操作，在这期间redis不能提供其他服务
- **BGSAVE**：redis开启一个子进程，由子进程负责创建RDB文件，而不会阻塞redis服务（**但这期间redis服务不允许进行SAVE,BGREWRITEAOF**）

**自动间隔型保存的配置和实现：**

``` shell
# redis.conf里如下配置(任意满足一下一种情况，都会执行BGSAVE命令)
save 900 1 # 服务器在900秒内，对数据库至少执行了1次修改
save 300 10  # 服务器在300秒内，对数据库至少执行了10次修改
save 60 10000  # 服务器在60秒内，对数据库至少执行了10000次修改
```

​		redis在启动时，读取这部分配置，并对每种情况都保存到saveparam中，这个数据结构有2个字段，一个是seconds（秒数），一个是changes（修改数），所以，redis启动后会创建3个saveparam。同时，redis还维持着一个dirty计数器，内部有2个字段，一个是dirty（修改次数），一个是lastsave（上次成功执行SAVE或BGSAVE的时间戳），当服务器每成功执行一个数据修改命令后，会将dirty加1。在检查是否需要执行BGSAVE命令的时间事件到达后，对每个条件都进行比对（当前时间戳 - lastsave），如果差值大于这个三指定的时间，同时dirty大于对应配置的修改次数，就执行BGSAVE，同时重置dirty和更新lastsave。

### 2.2 AOF（Append Only File）

​		保存的是服务器执行的写命令到文件里。当redis重启后，直接拿到aof文件，创建一个伪客户端并执行里面的写命令来还原数据（因为redis的命令只能在客户端上下文中执行）。**redis的执行是事件循环处理机制（和netty很像）。在一次循环里，先处理文件事件（即IO事件），再处理时间事件（即内部任务），最后再根据配置appendfsync考虑是否需要将aof缓冲区里的数据同步到aof文件里**

**实现步骤可分为3个：命令追加到aof缓冲末尾，将aof缓冲区里的内容写入到aof文件，同步aof文件到磁盘**

```shell
appendonly yes # 开启reids的aof
# 以下3选一，默认everysec。
appendfsync always
appendfsync everysec
appendfsync no
```

appendfsync的配置控制了3个步骤中的最后一步，即同步aof到文件磁盘，且这三个选择都会执行前两个步骤

- always：**每次都同步**。效率最慢，同时安全性最高，但**不代表完全不丢数据（最多丢失一个事件循环中产生的写命令数据）**
- everysec：**如果上次同步aof距离现在超过1秒，就执行同步**。默认的，开销不那么大，就算宕机，也**只丢失1秒内的写命令数据**
- no：**不进行同步，由操作系统决定何时同步**。速度最快，但可能会丢失更多的数据，同时，在一次同步数据中，累积的数据也是最多的，所以单次同步是花费时间最长的。

#### BGREWRITEAOF（AOF重写）

​		前面讨论的都是AOF的被动执行，AOF的主动执行通过BGREWRITEAOF命令执行，开启一个子进程执行操作（快照），从而不会阻塞当前redis服务。当然也可以通过conf文件的配置来自动执行AOF重写

​		BGREWRITEAOF并不会对现有的aof文件分析，而是直接分析当前数据库，并将其中的数据转化为写命令并保存到新的aof文件中，再用新的aof文件替换旧的，完成重写

**aof重写缓冲区：**

​		负责将子进程在重写期间而父进程（redis服务）操作了新的写操作命令写入到aof文件。它记录着在AOF重写期间，父进程新写入数据的命令。在AOF重写完毕后，再将重写缓冲区的内容刷新到新的AOF文件

相关可用配置：

```shell
# 必须两个同时满足才会触发AOF重写
auto-aof-rewrite-percentage 100 # 当前AOF文件的增长量大于上次AOF文件的100%，就会触发重写操作
auto-aof-rewrite-min-size 64mb # AOF重写的最低文件大小阈值

```

## 3. 单线程和事件循环机制

​		虽然redis是Reactor模式，使用IO的多路复用来支持并发的客户端操作。但redis会对每个客户端操作（连接or读取数据）封装为一个事件，并将其投入到一个事件队列里。redis服务端以有序，同步的方式弹出并执行这些事件。所以，redis是单线程执行任务的，**先处理文件事件，再处理时间事件，这两种事件不会并发执行，同时，这两种事件内部的子事件更不会并发执行**。

- 文件事件：套接字操作的抽象，IO事件
- 时间事件：redis内部的一些定时操作。所有的时间时间都放在一个无序的链表里（是执行时间无序，但最新生成的时间事件会放在链表头部），当时间时事件触发时，遍历这个链表，找出执行时间到达的时间事件并执行

####  3.1文件事件：

- 客户端的连接
- 读事件（即客户端传来的命令请求）
- 命令回复事件

#### 3.2 时间事件：

- 更新服务器的各类统计信息（时间、内存占用等）
- 清理过期键值对（定期删除时间事件）
- 清理和关闭无效的客户端
- 尝试进行AOF或RDB持久化
- 服务器为主服务器，要对从服务器进行同步
- 如果是集群模式下，心跳检测等

## 4. 多机数据库

 ### 4.1 复制（主从）

### 4.2 哨兵

### 4.3 集群

## 5 面试相关

### 5.1 缓存

- 缓存雪崩：同一时间过期大量key，导致这些请求全部打到DB上，造成数据库崩溃
  - 解决办法：对这些具有相同过期时间的key，对其ttl再增加一个随机值，让其不在同一时间失效

- 缓存穿透：对某个key既没缓存，数据库中也没有，导致每次请求都要再redis和数据库中查找。
  - 解决办法：不合理值的校验和布隆过滤器（就是把数据库中所有存在的数据标识到布隆过滤器中，不存在就直接返回，存在就查找缓存）
- 缓存击穿：某一个key过期，但这时有大量请求设置它，导致大量请求为了这个key而达到db上
  - 解决办法：一是设置不过期。二是可以用分布式锁来更新这个key（拿到锁后判断是否存在缓存）

### 5.2 常用的缓存读写策略

- **Cache Aside（旁路缓存）**：更新数据到数据库 -> 删缓存
- 延迟双删：删缓存 -> 更新数据到数据库 -> 休眠一段时间 -> 再删缓存
- **Read/Write Through（读写穿透）**
- **Write Behind （异步缓存写入）**

### 5.2 内存淘汰策略

​		主要是**LRU（Least Recently Used）和LFU（Least Frequently Used）**算法，LRU算法是淘汰链表尾部的元素，如果一个元素被访问过就放在链表的头部，其他元素在后面，根据这种方式，来算出元素的热度，排在最后的就是热度最低的，可以直接剔除。

​		但是这种算法会带来一个问题，如果一个key长时间都没有被访问，只是突然被用户访问了一下，就放到了链表的头部，这个元素在下次被淘汰发生时可能就被当成热点元素不被剔除

​		LFU(Least Frequently Used)算法引入了时间的概念，其根据最近一段时间的访问频率来得出该key是否要被淘汰，如果是冷数据，只是突然被访问了一下，将有很大的概率被淘汰掉。

- noeviction**：不淘汰任何数据，当内存不足时，新增操作会报错，`Redis` **默认内存淘汰策略**；**
- **allkeys-lru**：淘汰整个键值中最久未使用的键值；
- **allkeys-random**：随机淘汰任意键值;
- **volatile-lru**：淘汰所有设置了过期时间的键值中最久未使用的键值；
- **volatile-random**：随机淘汰设置了过期时间的任意键值；
- **volatile-ttl**：优先淘汰更早过期的键值。

在 `Redis 4.0` 版本中又新增了 2 种淘汰策略：

- **allkeys-lfu**：淘汰整个键值中最少使用的键值。
- **volatile-lfu**：淘汰所有设置了过期时间的键值中，最少使用的键值；