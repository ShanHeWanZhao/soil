# Mysql

## 1 索引相关

### 1.1 b+树

- 每一个节点能存储多个数据，但不存储整行信息，只存储行的索引值（一个节点能存储越多的数据，代表相同数据量下数据高度就越低，在查找时IO次数就越少）

- 非叶子节点不存储数据
- 叶子节点是个链表结构，便于遍历，也存储正真的行数据
- 查找更稳定，按主键搜索行数据，是必须查找到叶子节点的（IO次数就为树的高度）
- 正因为叶子节点是链表结构，可以很好的利用到空间局部性原理（如果一块磁盘被访问到，那么它周围的数据也可能被访问），读取周围部分节点，进行范围查找

### 1.2 b树

- 每个节点也能存储多个数据（就是行数据，就导致每个节点存储的行就越少，和b+树相比存储同样数据量的情况下，树的高度会越高）
- 叶子节点不是链表结构，不利于遍历（就算叶子节点又链表结构，但由于非叶子节点已经存储了部分数据，所以，范围查找时就会漏掉非叶子节点但在这区间的数据）
- 查找不够稳定（数据可能就在顶点，也可能在叶子节点）

### 1.3 b+树和b树高度计算

**b+树**

> ​		默认innodb的页大小为16kb，主键使用bigint为8byte，再加上下一页的指针，一般为6byte，一般表的一行数据大小设为1kb。所以，一个索引值占用14byte，那么，非叶子节点一个页能存储 (16 * 1024 )/14 = 1170条索引值数据，叶子节点一个页能存储 (16 * 1024) / 1 * 1024 = 16条真正的数据。所以，3层高度的b+树能存储 1170 *1170 *16 = 21902400条行数据。综上，3层高度的b+树就能存储2190万条数据左右（一行数据假设为1kb）,所以，可以大致估算出，2200万条数据内进行主键查询时，只需要固定的3次IO，还是很快的。

**b树**

> ​		初始值还是如上，16kb页大小，但b树每个节点存的都是完整的行数据（1kb），一个页能存 (16 / 1) = 16条行数据。（16 * 16 * 16 * 16 * 16 * 16）=1677万，所以，b树6层的高度大概才能存储1677万条数据（一行数据为1kb），也就导致了在磁盘IO时很不确定IO次数，运气好就在根节点，只IO一次。运气不好在叶子节点，要IO六次。况且这种行数据的分散存储在各节点的结构就不好支持范围查找

### 1.4 回表和覆盖索引

**回表：**

> ​		innodb使用主键的聚簇索引来存储数据，非主键索引叶子节点存储的时其对应的主键值，所以还需要用到这个主键索引值取正在的聚簇索引里去查找行数据

**覆盖索引：**

> ​	当mysql查询的列全部数据包含在一个一个索引中，且查询条件也可以命中这个索引，就可以使用覆盖索引，不用回表，一次就能查询出数据
>
> ​	比如表中A有(a,b,c)的聚合索引，查询sql为：SELECT b,c FROM A WHERE a = 1;这时查询可以走到索引，而需要的字段有全部在这个(a,b,c)的索引中，所以，不用回表

## 2 sql优化

从三个层面回答：

- 建表语句
  - 考虑组建联合索引（且区分度越高的放在越左边，因为索引排序是从左到右的，先命中左边，如果左边区分度越高，意味着能过滤掉更多的数据）
- sql本身上
  - 尽量使用覆盖索引，减少回表（也就意味着查询语句不要查询全部数据）
  - 绝不返回不必要的字段
  - 使用最左匹配
  - 不要再索引列直接参与函数计算
  - explain命令查看sql执行计划（查看命中的索引，索引大小，过滤行数的百分比等）
  - 表连接时尽量使小表驱动大表（对于join来说，实在不行可以使用straight join，强制左表驱动右表）
  - 减少表连接的个数（表join的越多，代表msyql就要花更多的时间分析sql，找出查找速度最快的那种连接方式。但考虑到mysql分析执行计划时不应该占用太多时间，所以连接多表时很难找到执行计划最优的那个方式）
- 代码里
  - 在事务内，尽量减少锁暂用时间（比如事务内的update和delete，因为update会触发行锁，索引如果可以就放在最后才执行）

## 3 事务隔离级别相关

### 3.1 READ UNCOMMITTED(读未提交)

​		读取到其他事务还未commit的数据，产生脏读。也就是事物之间还未commit或rollback的数据之间是可见的

### 3.2 READ COMMITED (读已提交)

​		读取到其他事务已经commit的数据，不会产生脏读，但由于能读取到其他事务已经commit的数据，所以可能造成一个事务前后两次读取的数据不一致，不可重复读。

### 3.3 REPEATABLE READ （可重复读，mysql的默认隔离级别）

​		读取不到其他事务已经commit的数据，一个事务执行期间，如果**另外一个事务对某个数据做了修改并且commit了，那第一个事务是读取不到的**，所以叫可重复读

**什么是幻读**：在一个事务内读取到了别的事务插入或删除的数据，导致前后读取不一致。

**可重复读隔离级别下是如何解决幻读的**：

- 对于**普通select操作，读的是快照，即用MVCC就可解决幻读**
- 对于**select ... for update操作，是当前读（即不会使用undo log），这时候会加临建锁来解决幻读，但同时也降低了性能，影响了并发度**（毕竟加的临建锁的这个范围导致这部分数据不能再进行增删改操作了）

### 3.4 SERIALIZABLE(串行化)

​	读写都加互斥锁，最慢但是不会产生脏读，幻读



## 4 其他重点

### 4.1 redo log，binlog，undo log

- redo log：innodb引擎专属，**崩溃恢复使用**
- binlog：server层，**主从复制、数据备份等使用**
- undo log：**事务回滚和MVCC使用**

> ​		磁盘上的redo log文件有一个叫做LSN(log sequence number)检查点的东西，它表示在LSN之前的数据(缓冲池中的数据页、索引页)都已经持久化到磁盘了，而LSN之后的数据，尚未来得及fsync到磁盘，因此发生故障时需要读取LSN之后的 redo log日志文件进行恢复。

### 4.2 mvcc

​	mvcc只工作在读已提交和可重复读的隔离级别下。innodb中每行记录后面保存了两个隐藏列，一个是**修改当前行数据的事务id（trx_id），另一个是指向undolog中这条数据的上次修改记录的指针**（所以，当有多个事务对一条数据修改时，undolog中当前行数据会形成一种链表结构）

​		一个事务读已提交每次读取都会生成新的read view，而可重复读只会在第一次读取这条数据时生成read view

**ReadView包含如下数据：**

> `trx_ids`: 指的是在创建 `ReadView` 时，当前数据库中「活跃事务」的事务 id 列表，注意是一个列表， **“活跃事务”指的就是，启动了但还没提交的事务**。
>
> `min_trx_id`: 指的是在创建 `ReadView` 时，**当前数据库中「活跃事务」中事务 id 最小的事务**，也就是 m_ids 的最小值。
>
> `max_trx_id`：这个并不是 `m_ids` 的最大值，而是**创建** `ReadView` **时当前数据库中应该给下一个事务的 id 值，也就是全局事务中最大的事务 id 值 + 1**；
>
> `creator_trx_id` ：指的是创建该 `ReadView` 的事务的事务 id

**对于当前事务来说，可通过如下读取当前数据的trx_id列来进行判断，有以下几种可能：**

> - 如果被访问版本的`trx_id`属性值与`ReadView`中的 `creator_trx_id` 值相同，意味着当前事务在访问它自己修改过的记录，所以该版本可以被当前事务访问。
> - 如果**trx_id < min_trx_id**，表示这个版本是已提交的事务或者是当前事务自己生成的，这个数据是可见的；
> - 如果**trx_id >= max_trx_id**，表示这个版本是由将来启动的事务生成的，是肯定不可见的；
> - 如果**min_trx_id <= trx_id < max_trx_id**
>   - 若 数据的`trx_id`在`trx_ids`数组中，表示这个版本是由还没提交的事务生成的，不可见, 去读取这条数据的历史版本，这条数据的历史版本中都包含了事务id信息，去查找第一个不在活跃事务数组的版本记录。
>   - 若 数据的`trx_id`不在`trx_ids`数组中，表示这个版本是已经提交了的事务生成的，可见。

### 4.3 explain（执行计划）

|      id       |           SELECT 查询的序列标识符            |
| :-----------: | :------------------------------------------: |
|  select_type  |         SELECT 关键字对应的查询类型          |
|     table     |                  用到的表名                  |
|  partitions   |    匹配的分区，对于未分区的表，值为 NULL     |
|     type      |               **表的访问方法**               |
| possible_keys |                可能用到的索引                |
|      key      |              **实际用到的索引**              |
|    key_len    |                所选索引的长度                |
|      ref      | 当使用索引等值查询时，与索引作比较的列或常量 |
|     rows      |               预计要读取的行数               |
|   filtered    |     按表条件过滤后，留存的记录数的百分比     |
|     Extra     |                 **附加信息**                 |

详情见[链接](https://javaguide.cn/database/mysql/mysql-query-execution-plan.html)

### 4.4 分库分表和分布式id

水平和垂直分表

- UUID

- 数据库自增（单独创建一张表）

- redis

- twitter的雪花算法（SnowFlake）

  ![](D:\work\code\soil\framework_summary\img\雪花算法.png)

  - **第1位**占用1bit，其值始终是0，可看做是符号位不使用。
  - **第2位**开始的41位是时间戳，41-bit位可表示2^41个数，每个数代表毫秒，那么雪花算法可用的时间年限是`(1L<<41)/(1000L360024*365)`=69 年的时间。
  - **中间的10-bit位**可表示机器数，即2^10 = 1024台机器，但是一般情况下我们不会部署这么台机器。如果我们对IDC（互联网数据中心）有需求，还可以将 10-bit 分 5-bit 给 IDC，分5-bit给工作机器。这样就可以表示32个IDC，每个IDC下可以有32台机器，具体的划分可以根据自身需求定义。
  - **最后12-bit位**是自增序列，可表示2^12 = 4096个数。

  这样的划分之后相当于**在一毫秒一个数据中心的一台机器上可产生4096个有序的不重复的ID**。但是雪花算法强**依赖机器时钟**，如果机器上时钟回拨，会导致发号重复或者服务会处于不可用状态。如果恰巧回退前生成过一些ID，而时间回退后，生成的ID就有可能重复

- 美团的leaf

### 4.5 为什么小表驱动大表？

表越小，筛选出来的数据就越少，join操作可以减少和大表的连接次数，加快查询速度

### 4.6 SQL语句的执行过程

![](img/mysql执行过程.png)

- 查询语句：权限校验（如果命中缓存） ->  查询缓存 -> 分析器 ->  优化器 -> 权限校验 -> 执行器  ->  引擎
- 更新语句：分析器 -> 权限校验 -> 执行器 -> 引擎 -> redo log(prepare 状态)  -> binlog -> redo log(commit 状态)

### 4.7 innodb行锁

- **记录锁（Record Lock）**：也被称为行锁，属于单个行记录上的锁。只能在**唯一索引或主键列**上使用
- **间隙锁（Gap Lock）**：锁定一个范围，不包括记录本身。
- **临键锁（Next-Key Lock）**：**记录锁和间隙锁的组合（左开为间隙锁，而右闭则为记录锁，也可以看成是一种特殊的间隙锁），它只与非唯一索引有关，锁定一个左开右闭的范围，包含记录本身**，主要目的是**为了解决可重复读隔离级别下当前读可能产生的幻读问题（即避免插入新记录）**。

### 4.8 索引失效场景

- **联合索引不满足最左匹配原则**
- 使用 **select * ，不能走覆盖所索引**
- **索引列参与计算**：比如 where id + 1= 2;
- **索引列使用函数**：如 where SUBSTR(id_no,1,3) = '100';
- 使用like时，**模糊匹配的占位符位于条件的首部**
- **参数类型与字段类型不匹配，导致类型发生了隐式转换，索引失效**
- **查询条件使用or关键字，其中一个字段没有创建索引，则会导致整个查询语句索引失效； or两边为“>”和“<”范围查询时，索引失效**

